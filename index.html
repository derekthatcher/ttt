<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>3D Tic Tac Toe</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            perspective: 1000px;
            /* Adjust this value for more or less depth */
            overflow: hidden;
            /* Prevent scrollbars if elements go out of view */
            height: 100vh;
            /* Ensure body takes full viewport height for centering */
            display: flex;
            /* Use flexbox for centering */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Center content vertically */
        }

        h1 {
            top: 0;
            position: absolute;
        }

        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Remove gap here, as we'll use translateY for spacing */
            margin-top: 0;
            /* No need for large top margin now */
            position: relative;
            transform-style: preserve-3d;
            /* Center the container itself using transforms */
            /* transform: translateY(0px) rotateX(-20deg) rotateY(0deg); /* Adjust overall tilt for the stack */
            /* Add a slight negative margin-top to pull the whole stack up a bit */
            margin-top: -200px;
            /* Adjust as needed to visually center */
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 70px);
            gap: 10px;
            border: 2px solid #333;
            background-color: #fff;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);

            position: absolute;
            /* Still needed for stacking */
            /* Remove top/left and initial translate(-50%, -50%) as we'll use direct translateY */
            transform-style: preserve-3d;
            width: fit-content;
            /* Ensure grid takes only necessary width */
            height: fit-content;
            /* Ensure grid takes only necessary height */
            margin: auto;
            /* Attempt to center if position absolute issues */
        }

        /* Individual grid transforms to create the stack with visible gaps */
        /* Adjust translateY to create vertical spacing */
        /* Adjust translateZ for depth */
        /* Adjust rotateX for individual grid tilt if desired */

        /* Top Grid (z=0) */
        /* This targets the div containing the grid for z=0 */
        .grid-container>div:nth-child(1) {
            transform: translateY(-112px) rotateX(61deg) translateZ(16px);
            z-index: 3;
        }

        /* Middle Grid (z=1) */
        .grid-container>div:nth-child(2) {
            transform: translateY(-10px) rotateX(65deg) translateZ(16px);
            /* Reference point, no extra Y or Z movement */
            z-index: 2;
        }

        /* Bottom Grid (z=2) */
        .grid-container>div:nth-child(3) {
            transform: translateY(105px) rotateX(65deg) translateZ(16px);
            /* Move down, tilt backward, push further */
            z-index: 1;
        }

        .cell {
            width: 80px;
            height: 70px;
            border: 1px solid #000;
            display: flex;
            flex-direction: column;
            /* Stack label and content */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 35px;
            font-weight: bold;
            background-color: #eee;
            /* Lighter background for cells */
        }

        .cell:hover {
            background-color: #d0d0d0;
        }

        .cell.pulseY {
            animation: cell-pulseY 2s ease-out forwards;
            /* Apply the animation */
        }

        @keyframes cell-pulseY {
            0% {
                background-color: transparent;
                /* Start with no background or original */
                box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7);
                /* Yellow glow, fully opaque */
                transform: scale(1);
                /* No scaling initially */
            }

            50% {
                background-color: #3bff6c;
                /* A bright yellow for the peak of the pulse */
                box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0);
                /* Yellow glow, fading out */
                transform: scale(1.05);
                /* Slightly enlarge the cell */
            }

            100% {
                background-color: transparent;
                /* Fade back to transparent */
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
                /* Glow completely gone */
                transform: scale(1);
                /* Return to original size */
            }
        }

        .cell.pulseG {
            animation: cell-pulseG 2s ease-out forwards;
            /* Apply the animation */
        }

        @keyframes cell-pulseG {
            0% {
                background-color: transparent;
                /* Start with no background or original */
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.7);
                /* Yellow glow, fully opaque */
                transform: scale(1);
                /* No scaling initially */
            }

            50% {
                background-color: #ffeb3b;
                /* A bright yellow for the peak of the pulse */
                box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0);
                /* Yellow glow, fading out */
                transform: scale(1.05);
                /* Slightly enlarge the cell */
            }

            100% {
                background-color: transparent;
                /* Fade back to transparent */
                box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
                /* Glow completely gone */
                transform: scale(1);
                /* Return to original size */
            }
        }

        #scoreboard {
            margin-top: 40vh;
            /* Adjust this to place it below the stack. Will need tweaking. */
            position: absolute;
            z-index: 5;
            bottom: 0;
            left: 0;

        }

        #playType {
            margin-top: 40vh;
            /* Adjust this to place it below the stack. Will need tweaking. */
            position: absolute;
            z-index: 5;
            bottom: 25px;
            right: 10px;

        }

        .winner {
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h1>3D Tic Tac Toe</h1>
    <div class="grid-container" id="grids"></div>
    <div id="scoreboard">
        <p>Player X: <span id="scoreX">0</span></p>
        <p>Player O: <span id="scoreO">0</span></p>
    </div>
    <div id="playType"><input type="checkbox" id="aiPlay" name="aiPlay" value="aiPlay"></div>
    <script>

        const scores = { X: 0, O: 0 };
        const winningLines3D = [];
        let currentPlayer = 'X';
        let aiPlayer = false; // if true ai player plays 'O'
        const aiPlayCheckbox = document.getElementById('aiPlay');
        createWinStates();
        // Create 3 grids with labels
        const gridContainer = document.getElementById('grids');
        const grids = Array.from({ length: 3 }, () =>
            Array.from({ length: 3 }, () => Array(3).fill(''))
        );
        printGrids();

        function printGrids() {
            // y is vertical (layers), x is horizontal, z is coming forward
            for (let y = 0; y < 3; y++) {
                const grid = document.createElement('div');
                grid.className = 'grid';
                for (let z = 0; z < 3; z++) {
                    for (let x = 0; x < 3; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.z = z;
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.addEventListener('click', handleCellClick);
                        grid.appendChild(cell);
                    }
                }
                gridContainer.appendChild(grid);
            }
        }

        aiPlayCheckbox.addEventListener('change', function () {
            // toggle aiplayer
            aiPlayer = this.checked;

        });

        function handleCellClick(event) {
            const cell = event.target;
            //console.log(cell);
            const z = Number(cell.dataset.z);
            const x = Number(cell.dataset.x);
            const y = Number(cell.dataset.y);


            // Prevent overwriting a cell
            if (grids[y][x][z] !== '') {
                return;
            }
            // Update cell and grid state
            cell.textContent = currentPlayer;
            grids[y][x][z] = currentPlayer;

            // Check for 3-in-a-row
            checkForWin([y, x, z], currentPlayer);

            if (aiPlayer) {
                // if ai player then make ai move straight away.
                setTimeout(() => {
                    aiMove();
                }, 800); // 800ms delay
                // no need to switch player.
            } else {
                // Switch player
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                console.log("Next go: ", currentPlayer);
            }
        }

        function aiMove() {
            // ai player make move for 'O'
            // random at first?
            // Keep track of visited cells to prevent infinite loops if grid is full
            const totalCells = 27;
            let attempts = 0;

            while (attempts < totalCells) { // Limit attempts to prevent infinite loop on full grid
                const x = getRandomInt(0, 2);
                const y = getRandomInt(0, 2);
                const z = getRandomInt(0, 2);

                if (grids[y][x][z] === '') {
                    console.log({ y, x, z }); // Found an empty cell!
                    // add 'O' to grids
                    grids[y][x][z] = 'O';
                    // find cell on screen, add 'O'
                    const aiCell = document.querySelector(`div.cell[data-x="${x}"][data-y="${y}"][data-z="${z}"]`);
                    aiCell.textContent = 'O';
                    // check for winning position
                    checkForWin([y, x, z], 'O');
                    // jump out of while loop.
                    attempts = totalCells;
                }
                attempts++;
            }
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function createWinStates() {
            // Define all 49 possible winning lines using [z, y, x] coordinates
            // 1. Lines along X-axis (rows within each grid) - 3 grids * 3 rows = 9 lines
            for (let z = 0; z < 3; z++) {
                for (let y = 0; y < 3; y++) {
                    winningLines3D.push([[z, y, 0], [z, y, 1], [z, y, 2]]);
                }
            }

            // 2. Lines along Y-axis (columns within each grid) - 3 grids * 3 columns = 9 lines
            for (let z = 0; z < 3; z++) {
                for (let x = 0; x < 3; x++) {
                    winningLines3D.push([[z, 0, x], [z, 1, x], [z, 2, x]]);
                }
            }

            // 3. Lines along Z-axis (vertical lines through the grids) - 3 rows * 3 columns = 9 lines
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    winningLines3D.push([[0, y, x], [1, y, x], [2, y, x]]);
                }
            }

            // 4. Diagonals within each XY plane (2D diagonals) - 3 grids * 2 diagonals = 6 lines
            for (let z = 0; z < 3; z++) {
                winningLines3D.push([[z, 0, 0], [z, 1, 1], [z, 2, 2]]); // Top-left to bottom-right
                winningLines3D.push([[z, 0, 2], [z, 1, 1], [z, 2, 0]]); // Top-right to bottom-left
            }

            // 5. Diagonals within each XZ plane (slice diagonals when looking from front/back) - 3 columns * 2 diagonals = 6 lines
            for (let x = 0; x < 3; x++) {
                winningLines3D.push([[0, 0, x], [1, 1, x], [2, 2, x]]); // Front-top to back-bottom
                winningLines3D.push([[0, 2, x], [1, 1, x], [2, 0, x]]); // Front-bottom to back-top
            }

            // 6. Diagonals within each YZ plane (slice diagonals when looking from side) - 3 rows * 2 diagonals = 6 lines
            for (let y = 0; y < 3; y++) {
                winningLines3D.push([[0, y, 0], [1, y, 1], [2, y, 2]]); // Left-front to right-back
                winningLines3D.push([[0, y, 2], [1, y, 1], [2, y, 0]]); // Right-front to left-back
            }

            // 7. Space Diagonals (main 3D diagonals) - 4 lines
            winningLines3D.push([[0, 0, 0], [1, 1, 1], [2, 2, 2]]); // Corner to opposite corner
            winningLines3D.push([[0, 0, 2], [1, 1, 1], [2, 2, 0]]); // Corner to opposite corner
            winningLines3D.push([[0, 2, 0], [1, 1, 1], [2, 0, 2]]); // Corner to opposite corner
            winningLines3D.push([[0, 2, 2], [1, 1, 1], [2, 0, 0]]); // Corner to opposite corner
            //console.log(winningLines3D);
        }

        function addPulseEffect(cellElement, currentPlayer) {
            if (cellElement) {
                if (currentPlayer == 'X') {
                    // Remove the class first to allow the animation to re-trigger if already present
                    // This is important if you want to pulse the same cell multiple times
                    cellElement.classList.remove('pulseY');

                    // Force a reflow/repaint to ensure the animation restarts
                    void cellElement.offsetWidth;

                    // Add the class to trigger the animation
                    cellElement.classList.add('pulseY');

                    // The animation duration is 1s, so we'll remove it slightly after.
                    setTimeout(() => {
                        cellElement.classList.remove('pulseY');
                    }, 2100); // Slightly longer than the animation duration
                } else {
                    // Remove the class first to allow the animation to re-trigger if already present
                    // This is important if you want to pulse the same cell multiple times
                    cellElement.classList.remove('pulseG');

                    // Force a reflow/repaint to ensure the animation restarts
                    void cellElement.offsetWidth;

                    // Add the class to trigger the animation
                    cellElement.classList.add('pulseG');

                    // The animation duration is 1s, so we'll remove it slightly after.
                    setTimeout(() => {
                        cellElement.classList.remove('pulseG');
                    }, 2100); // Slightly longer than the animation duration
                }
            }
        }

        function arraysEqual(a, b) {
            // are the two arrays equal
            if (a === b) return true;
            if (a == null || b == null) return false;
            if (a.length !== b.length) return false;

            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function checkForWin(playedCell, currentPlayer) {
            scores.X = 0;
            scores.O = 0;

            // loop through winning lines, and count all that have same character.
            for (const line3D of winningLines3D) {
                const coord1 = line3D[0];
                const coord2 = line3D[1];
                const coord3 = line3D[2];
                let justPlayed = false;
                if (arraysEqual(line3D[0], playedCell) || arraysEqual(line3D[1], playedCell) || arraysEqual(line3D[2], playedCell)) {
                    justPlayed = true;
                }

                // y, x, z of the three in a rows
                const y1 = coord1[0];
                const x1 = coord1[1];
                const z1 = coord1[2];

                const y2 = coord2[0];
                const x2 = coord2[1];
                const z2 = coord2[2];

                const y3 = coord3[0];
                const x3 = coord3[1];
                const z3 = coord3[2];

                const val1 = grids[y1][x1][z1];
                const val2 = grids[y2][x2][z2];
                const val3 = grids[y3][x3][z3];

                if (val1 && val1 === val2 && val1 === val3) {
                    scores[val1]++;
                    // now pulse winning rows - change to only when includes last placement.
                    if (justPlayed) {
                        const t1 = document.querySelector(`div.cell[data-x="${x1}"][data-y="${y1}"][data-z="${z1}"]`);
                        addPulseEffect(t1, currentPlayer);
                        const t2 = document.querySelector(`div.cell[data-x="${x2}"][data-y="${y2}"][data-z="${z2}"]`);
                        addPulseEffect(t2, currentPlayer);
                        const t3 = document.querySelector(`div.cell[data-x="${x3}"][data-y="${y3}"][data-z="${z3}"]`);
                        addPulseEffect(t3, currentPlayer);
                    }
                }
            }

            // Update scoreboard
            document.getElementById('scoreX').textContent = scores.X;
            document.getElementById('scoreO').textContent = scores.O;
            document.getElementById('scoreX').classList.remove("winner");
            document.getElementById('scoreO').classList.remove("winner");
            if (scores.X > scores.O) {
                document.getElementById('scoreX').classList.add("winner");
            } else if (scores.O > scores.X) {
                document.getElementById('scoreO').classList.add("winner");
            }
        }
    </script>
</body>

</html>